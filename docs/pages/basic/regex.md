正则匹配基础知识 `JavaScript正则表达式迷你书`
> 正则表达式是匹配模式，要么匹配字符，要么匹配位置


## 正则表达式字符匹配攻略

### 1. 两种模糊匹配
#### 1.1 横向模糊匹配
横向模糊匹配：一个正则可匹配的字符串长度不是固定的，可以是多种情况，常用的{m，n}

```js
    var regex = /ab{2,5}c/g;
    var string = "abc abbc abbbc abbbbc abbbbbc abbbbbbc";
    console.log( string.match(regex) ); 
    // => ["abbc", "abbbc", "abbbbc", "abbbbbc"]
```

#### 1.2 纵向模糊匹配
纵向模糊匹配：一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能

例如 `/a[123]b/`可以匹配三种字符： 'a1b', 'a2b','a3b'

### 2. 字符组
#### 2.1 范围表示法
`[a-z]`表示a到z中的所有字符， 如果要匹配 a, z, -三个字符，写成 `[az-]`或者`[-az]`或者转义 `[a\-z]`
#### 2.2 排除字符组
纵向模糊匹配：排除字符组的概念， 例如`[^abc]`，表示除了'a','b','c'之外的任意一个字符都行。 字符组的第一位放`^`表示求反的概念
#### 2.3常见的简写形式
>`\d`表示`[0-9]`表示是一位数字
>`\D`表示`[^0-9]`表示数字外的任意字符
>`\w`表示`[0-9a-zA-Z_]`表示 数字 字母 下划线
>`\W`表示`[^0-9a-zA-Z_]`非单词的字符
>`\s`表示`[ \t\v\n\r\f]`表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符
>`\S`表示`[^ \t\v\n\r\f]` 非空白符
> `.`表示`[^\n\r\u2028\u2029]`通配符，几乎表示任意字符， 换行符、回车符，行分隔符和段分隔符除外

匹配任务字符： `[\d\D]` `[\w\W]` `[^]` `[\s\S]`任意一个

### 3. 量词
量词也是重复，重复的次数
#### 3.1 简写形式
>`{m,}`表示最少出现m次
>`{m}`表示出现m次，等价于`${m,m}`
> `?`等价于`{0,1}`，表示出现或者不出现
>`+`等价于`{1,}`至少出现一次
>`*` 等价于`{0,}`

#### 3.2贪婪匹配和惰性匹配
贪婪匹配，例如：
```js
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) ); 
// => ["123", "1234", "12345", "12345"]

```
正则会尽可能多的匹配，，只要匹配，越多越好

惰性匹配，例如
```js
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) ); 
// => ["12", "12", "34", "12", "34", "12", "34", "56"]

```
只要符合就不在往后尝试
通过网量词后面添加`？`就能实现惰性
>`{m,n}?`


### 4. 多选分支
一个模式可以实现横向和纵向模糊匹配， 而多选分支可以支持多个子模式任选其一

具体形式如下：`(p1|p2|p3)`，其中`p1`,`p2`,`p3`都是子模式， 用`|`管道符分隔，表示其中任意一个

例如： 要匹配`aa`或者`bb`,可以写成 `/aa|bb/`

测试
```js
var regex = /good|goodbye/g;
var string = "goodbye";
console.log( string.match(regex) );
// => ["good"]
```
```js
var regex = /goodbye|good/g;
var string = "goodbye";
console.log( string.match(regex) );
// => ["goodbye"]
```

通过上面测试说明，分支结构也是有惰性的，及当前面的匹配上了，后面的就不在尝试了

### 5. 案例说明
#### 5.1 匹配16进制颜色值
要求：
```js
#ffbbad
#Fc01DF
#FFF
#ffE
```
分析：16进制组成0-9A-Fa-f,组成位数为3位或者6位
```js
const regex= /#([0-9a-zA-Z]{3}|[0-9a-zA-Z]{6})/g
const str='#ffbbad #Fc01DF #FFF #ffE'
str.match(regex)
// ["#ffb", "#Fc0", "#FFF", "#ffE"]
```

#### 5.2 匹配时间
要求
```js
23:59
 
```
分析：第一位数字0-2 第二位数字 0-3 或者 0-9（第一位不是2时） 第三位数字 0-5 第四位数字 0-9

```js
const regex = /([01][0-9]|2[0-3]):[0-5][0-9]/g
const str = '23:59 02:07'
str.match(regex)
// ['23:59', '02:07']
```
如果要求匹配`7:9`，也就是时分前面的0可以省略
```js
const regex = /([0]?[0-9]|[1][0-9]|[2][0-3]):([0]?[0-9]|[1-5][0-9])/g
const str = '23:59 02:07 7:9'
str.match(regex)
//  ['23:5', '02:07', '7:9']
```

#### 5.3 匹配日期
要求：
```
2017-06-10
```
分析： 年 `[0-9]{4}` 月 `[0][0-9]|[1][0-2]` 日 `[0][1-9]|[12][0-9]|[3][01]`